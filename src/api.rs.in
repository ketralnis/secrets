// API objects that are passed via HTTP, implemented with serde code generation
// for convenience

// I'm built by build.rs (specified in Cargo.toml)

use std::collections::HashMap;
use std::io::Cursor;
use std::io::{Read, Write};

use flate2::Compression;
use flate2::read::ZlibDecoder;
use flate2::write::ZlibEncoder;
use rusqlite;
use rustc_serialize::base64::{FromBase64, ToBase64};
use rustc_serialize::base64::STANDARD as STANDARD_BASE64_CONFIG;
use rustc_serialize::hex::ToHex;
use serde_json::from_slice as json_from_slice;
use serde_json::ser::to_string as json_to_string;
use sodiumoxide::crypto::box_;
use sodiumoxide::crypto::sign;

use common::SecretsError;
use keys::CryptoError;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub username: String,
    pub public_key: box_::PublicKey,
    pub public_sign: sign::PublicKey,
    pub ssl_fingerprint: String,
    pub created: i64,
    pub disabled: Option<i64>,
}

impl User {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let public_key: Vec<u8> = row.get("public_key");
        let public_key = try!(box_::PublicKey::from_slice(&public_key.as_ref())
            .ok_or(CryptoError::CantDecrypt));

        let public_sign: Vec<u8> = row.get("public_sign");
        let public_sign = try!(sign::PublicKey::from_slice(&public_sign.as_ref())
            .ok_or(CryptoError::CantDecrypt));

        let u = User {
            username: row.get("username"),
            public_key: public_key,
            public_sign: public_sign,
            ssl_fingerprint: row.get("ssl_fingerprint"),
            created: row.get("created"),
            disabled: row.get("disabled"),
        };
        Ok(u)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub name: String,
    pub created: i64,
    pub modified: i64,
    pub creator: String,
    pub modified_by: String
}

impl Service {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let s = Service {
            name: row.get("service_name"),
            created: row.get("created"),
            modified: row.get("modified"),
            creator: row.get("creator"),
            modified_by: row.get("modified_by"),
        };
        Ok(s)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Grant {
    pub grantee: String,
    pub grantor: String,
    pub service_name: String,
    pub ciphertext: Vec<u8>,
    pub signature: sign::Signature,
    pub created: i64,
}

impl Grant {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let sig: Vec<u8> = row.get("signature");
        let signature = try!(
            sign::Signature::from_slice(&sig)
            .ok_or(CryptoError::CantDecrypt));

        let u = Grant {
            grantee: row.get("grantee"),
            grantor: row.get("grantor"),
            service_name: row.get("service_name"),
            ciphertext: row.get("ciphertext"),
            signature: signature,
            created: row.get("created"),
        };
        Ok(u)
    }

    pub fn key(&self) -> String {
        return Self::make_key(&self.service_name, &self.grantee);
    }

    pub fn make_key(service_name: &str, grantee: &str) -> String {
        return format!("{}::{}", service_name, grantee);
    }

    pub fn split_key(key: &str) -> (String, String) {
        let splitted: Vec<&str> = key.splitn(2, "::")
            // .map(|s| s.to_string())
            .collect();
        return (splitted[0].to_string(), splitted[1].to_string());
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse {
    pub healthy: Option<bool>,
    pub users: HashMap<String, User>,
    pub services: HashMap<String, Service>,
    pub grants: HashMap<String, Grant>,
    pub error: Option<String>,
    pub server_info: Option<PeerInfo>,
}

impl ApiResponse {
    pub fn new() -> Self {
        ApiResponse {
            healthy: None,
            users: HashMap::new(),
            services: HashMap::new(),
            grants: HashMap::new(),
            error: None,
            server_info: None,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PeerInfo {
    pub cn: String,
    pub fingerprint: String,
    pub public_key: box_::PublicKey,
    pub public_sign: sign::PublicKey,
}

impl PeerInfo {
    pub fn printable_report(&self) -> String {
        // TODO rfc1751 encoding of these
        return format!("\
            common name: {}\n\
            fingerprint: {}\n\
            public key: {}\n\
            public sign: {}",
        self.cn, self.fingerprint,
        self.public_key.as_ref().to_hex(),
        self.public_sign.as_ref().to_hex());
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinRequest {
    pub server_info: PeerInfo,
    pub client_info: PeerInfo,
}

impl JoinRequest {
    pub fn to_pastable(&self) -> Result<String, SecretsError> {
        let as_json_string = try!(json_to_string(&self));
        let mut encoder = ZlibEncoder::new(Vec::new(), Compression::Best);
        try!(encoder.write(&as_json_string.as_bytes()));
        let compressed = try!(encoder.finish());
        let b64 = compressed.to_base64(STANDARD_BASE64_CONFIG);
        return Ok(b64);
    }

    pub fn from_pastable(data: &[u8]) -> Result<Self, SecretsError> {
        let unb64d = try!(data.from_base64()
            .map_err(|_| CryptoError::CantDecrypt));
        let cursor = Cursor::new(unb64d);
        let mut decoder = ZlibDecoder::new(cursor);
        let mut decompressed = Vec::new();
        try!(decoder.read_to_end(&mut decompressed)
            .map_err(|_| CryptoError::CantDecrypt));
        let ret = try!(json_from_slice(&decompressed));
        return Ok(ret);
    }
}
