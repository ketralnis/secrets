// API objects that are passed via HTTP, implemented with serde code generation
// for convenience

use rusqlite;
use rustc_serialize::base64::{FromBase64, ToBase64};
use rustc_serialize::base64::STANDARD as STANDARD_BASE64_CONFIG;
use serde_json;
use serde_json::from_slice as json_from_slice;
use serde_json::ser::to_string as json_to_string;
use sodiumoxide::crypto::box_;
use sodiumoxide::crypto::sign;

use common::SecretsError;
use keys::CryptoError;
use utils;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub username: String,
    pub public_key: box_::PublicKey,
    pub public_sign: sign::PublicKey,
    pub ssl_fingerprint: String,
    pub created: i64,
    pub disabled: Option<i64>,
}

impl User {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let public_key: Vec<u8> = row.get("public_key");
        let public_key = try!(box_::PublicKey::from_slice(&public_key.as_ref())
            .ok_or(CryptoError::CantDecrypt));

        let public_sign: Vec<u8> = row.get("public_sign");
        let public_sign = try!(sign::PublicKey::from_slice(&public_sign.as_ref())
            .ok_or(CryptoError::CantDecrypt));

        let u = User {
            username: row.get("username"),
            public_key: public_key,
            public_sign: public_sign,
            ssl_fingerprint: row.get("ssl_fingerprint"),
            created: row.get("created"),
            disabled: row.get("disabled"),
        };
        Ok(u)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub service_name: String,
    pub created: i64,
    pub modified: i64,
    pub creator: String,
    pub modified_by: String
}

impl Service {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let s = Service {
            service_name: row.get("service_name"),
            created: row.get("created"),
            modified: row.get("modified"),
            creator: row.get("creator"),
            modified_by: row.get("modified_by"),
        };
        Ok(s)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Grant {
    pub grantee: String,
    pub grantor: String,
    pub service_name: String,
    pub ciphertext: Vec<u8>,
    pub signature: sign::Signature,
    pub created: i64,
}

impl Grant {
    pub fn from_row(row: rusqlite::Row) -> Result<Self, SecretsError> {
        let sig: Vec<u8> = row.get("signature");
        let signature = try!(
            sign::Signature::from_slice(&sig)
            .ok_or(CryptoError::CantDecrypt));

        let u = Grant {
            grantee: row.get("grantee"),
            grantor: row.get("grantor"),
            service_name: row.get("service_name"),
            ciphertext: row.get("ciphertext"),
            signature: signature,
            created: row.get("created"),
        };
        Ok(u)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse {
    pub healthy: Option<bool>,
    pub users: Vec<User>,
    pub services: Vec<Service>,
    pub grants: Vec<Grant>,
    pub error: Option<String>,
    pub server_info: Option<PeerInfo>,
}

impl ApiResponse {
    pub fn new() -> Self {
        ApiResponse {
            healthy: None,
            users: vec![],
            services: vec![],
            grants: vec![],
            error: None,
            server_info: None,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PeerInfo {
    pub cn: String,
    pub fingerprint: String,
    pub public_key: box_::PublicKey,
    pub public_sign: sign::PublicKey,
}

impl PeerInfo {
    pub fn printable_report(&self) -> String {
        // TODO rfc1751 encoding of these
        return format!("\
            common name: {}\n\
            fingerprint: {}\n\
            public key: {}\n\
            public sign: {}",
        self.cn, self.fingerprint,
        utils::hex(&self.public_key.as_ref()),
        utils::hex(&self.public_sign.as_ref()));
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinRequest {
    pub server_info: PeerInfo,
    pub client_info: PeerInfo,
}

impl JoinRequest {
    pub fn to_pastable(&self) -> Result<String, serde_json::Error> {
        let as_json_string = try!(json_to_string(&self));
        let b64 = as_json_string.as_bytes().to_base64(STANDARD_BASE64_CONFIG);
        return Ok(b64);
    }

    pub fn from_pastable(data: &[u8]) -> Result<Self, SecretsError> {
        // TODO gzip this, it's huge
        let json_str = try!(data.from_base64()
            .map_err(|_| CryptoError::CantDecrypt));
        let ret: Self = try!(json_from_slice(&json_str));
        return Ok(ret);
    }
}
